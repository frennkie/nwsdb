import bcrypt
import datetime
import json
from flask.ext.login import UserMixin
from flask.ext.sqlalchemy import SQLAlchemy
from sqlalchemy_utils import IPAddressType
from sqlalchemy import asc, desc
from libnmap.parser import NmapParser, NmapParserException
from libnmap.plugins.backendpluginFactory import BackendPluginFactory

from bson.objectid import ObjectId
from nmapui import app
from nmapui import db
from nmapui import login_serializer
from nmapui.celeryapp import celery_pipe
from celery.task.control import revoke




class Users(object):
    """ """

    @classmethod
    def find(cls, **kwargs):
        """ find Users from database
        Args:
            cls (Class):
            **kwargs: Optional

        Returns:
            List of User objects

        Examples:
            TODO

        """
        _users = []
        _dbusers = User.query.filter_by(**kwargs)
        for _dbuser in _dbusers:
            _users.append(User(id=_dbuser.id,
                          username=_dbuser.username,
                          password=_dbuser.password,
                          email=_dbuser.email))
        return _users

    @classmethod
    def get(cls, user_id):
        """get excactly one user identified by ID"""

        _user = None
        _dbuser = User.query.get(user_id)
        _user = User(id=_dbuser.id,
                     username=_dbuser.username,
                     password=_dbuser.password,
                     email=_dbuser.email)
        return _user

    @classmethod
    def add(cls, username=None, email=None, password=None):
        """add new user to database"""

        if not (username and email and password):
            print("Error: username, email and password are all mandatory!")
            raise ValueError("Neither username, email nor password can be None!")

        if len(Users.find(username=username)) > 0:
            print("Error: username already in use!")
            raise ValueError("username in use")
        else:
            new_user = User(username=username, email=email, password=password)
            db.session.add(new_user)
            db.session.commit()
            return new_user

""" permissions handles many-to-many relation of Permission and User Class """
permissions = db.Table('permissions',
    db.Column('permission_id', db.Integer, db.ForeignKey('permission.id')),
    db.Column('user_id', db.Integer, db.ForeignKey('user.id'))
)

class User(db.Model, UserMixin):
    """User Class and SQL Table"""
    __table_args__ = {'sqlite_autoincrement': True}
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(128))
    password = db.Column(db.String(128))
    email = db.Column(db.String(128))
    nmaptasks = db.relationship('NmapTask', backref=db.backref('buser'))
    permissions = db.relationship('Permission',
                                  secondary=permissions,
                                  lazy='dynamic',
                                  backref=db.backref('users', lazy='dynamic'))

    def __init__(self, id=None, username=None, email=None, password=None):
        self.id = id
        self.username = username
        self.password = password
        self.email = email

    def __repr__(self):
        return "<{0} {1}: {2}>".format(self.__class__.__name__,
                                       self.username,
                                       self.email)

    def get_auth_token(self):
        """Encode a secure token for cookie"""
        data = [str(self.id), self.password]
        return login_serializer.dumps(data)

    def credentials_valid(self, _password):
        _db_password_utf8 = self.password.encode('utf-8')
        return bcrypt.hashpw(_password.encode('utf-8') + app.config["PEPPER"],
                             _db_password_utf8) == _db_password_utf8

    def change_password(self, _password):
        db.session.query(User).filter(User.id == self.id).update({'password': _password})
        db.session.commit()

    def has_permission(self, name):
        """Check out whether a user has a permission or not."""
        permission = Permission.query.filter_by(name=name).first()
        # if the permission does not exist or was not given to the user
        if not permission or not permission in self.permissions:
            return False
        return True

    def grant_permission(self, name):
        """Grant a permission to a user."""
        permission = Permission.query.filter_by(name=name).first()
        if permission and permission in self.permissions:
            return
        if not permission:
            permission = Permission()
            permission.name = name
            db.session.add(permission)
            db.session.commit()
        self.permissions.append(permission)

    def revoke_permission(self, name):
        """Revoke a given permission for a user."""
        permission = Permission.query.filter_by(name=name).first()
        if not permission or not permission in self.permissions:
            return
        self.permissions.remove(permission)


class Permission(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(20))

    def __init__(self, id=None, name=None):
        self.id = id
        self.name = name

    def __repr__(self):
        return "<{0} {1}: {2}>".format(self.__class__.__name__,
                                       self.id,
                                       self.name)

    @classmethod
    def add(cls, id=None, name=None):
        """Add new permission"""
        if name is None:
            print("name is required!")
            raise("name is required!")
            return None
        if id:
            # TODO check whether id is free
            pass

        _new_perm = Permission(id=id, name=name)
        db.session.add(_new_perm)
        db.session.commit()
        return _new_perm.id

class NmapTask(db.Model):
    """ NmapTask Class """
    id = db.Column(db.Integer, primary_key=True)
    task_id = db.Column(db.String(36))
    comment = db.Column(db.String(128))
    created = db.Column(db.DateTime)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"))

    def __init__(self, id=None, comment=None, task_id=None, user=None,
                 created=datetime.datetime.utcnow()):
        self.id = id
        self.comment = comment
        self.task_id = task_id
        self.user_id = user.id
        self.created = created

    def __repr__(self):
        return "<{0} {1}: {2}>".format(self.__class__.__name__,
                                       self.id,
                                       self.task_id)

    @classmethod
    def find(cls, sort_asc=True, **kwargs):
        _reports = []

        if sort_asc is True:
            _dbreports = NmapTask.query.filter_by(**kwargs).order_by(asc("id"))
        else:
            _dbreports = NmapTask.query.filter_by(**kwargs).order_by(desc("id"))


        for _dbreport in _dbreports:
            _nmap_task = {'task_id': celery_pipe.AsyncResult(_dbreport.task_id),
                          'comment': _dbreport.comment,
                          'created': _dbreport.created,
                          'user_id': int(_dbreport.user_id)}
            _reports.append(_nmap_task)
        return _reports


    @classmethod
    def get(cls, task_id):
        #print("DEBUG: nmaptask_get: " + str(task_id))
        _report = None
        if isinstance(task_id, str) or isinstance(task_id, unicode):
            try:
                # TODO this shouldn't go look into AsyncResult.. or should it?
                _resultdict = celery_pipe.AsyncResult(task_id).result
            except NmapParserException as e:
                print e
        #print("DEBUG: nmaptask_get resultdict: " + str(_resultdict))
        return _resultdict

    @classmethod
    def get_report(cls, task_id):
        #print("DEBUG: nmaptask_getreport: " + task_id)
        _report = None
        if isinstance(task_id, str) or isinstance(task_id, unicode):
            try:
                _resultdict = celery_pipe.AsyncResult(task_id).result
                _resultxml = _resultdict['report']
                _report = NmapParser.parse_fromstring(_resultxml)
            except NmapParserException as e:
                print e
        return _report

    @classmethod
    def add(cls, user=None, task_id=None, comment=None):
        rval = False
        if user is not None and task_id is not None and comment is not None:
            new_nmaptask = NmapTask(user=user,
                                    task_id=task_id, comment=comment)
            db.session.merge(new_nmaptask)
            db.session.commit()
            rval = True
        return rval

    @classmethod
    def remove_task_by_id(cls, task_id=task_id):
        """  """

        try:
            if task_id is not None:
                nt = NmapTask.query.filter(NmapTask.task_id == task_id).one()
                db.session.delete(nt)
                db.session.commit()
                return True
            else:
                return False

        except Exception as e:
            print("Error: " + str(e))
            return False

    @classmethod
    def stop_task_by_id(cls, task_id=task_id):
        """  """
        print("This is not implemented1")
        """
        print("trying to stop " + task_id)
        try:
            #revoke(task_id, terminate=True, signal="SIGUSR1")
            revoke(task_id, terminate=True)
            return True
        except Exception as e:
            print(e)
            return False
        """
        return False


class NmapReportDiffer(object):
    """Foo"""

    def __init__(self, old_report=None, new_report=None):
        self.changed = []
        self.added = []
        self.removed = []
        print old_report
        if old_report and new_report:
            print "using given old and new_report"
            #pass
        else:
            print "no valid data.. taking dummy files from disk"
            old_report = NmapParser.parse_fromfile('nmapui/test/1_hosts.xml')
            new_report = NmapParser.parse_fromfile('nmapui/test/1_hosts_diff.xml')

        self.do_diff(new_report, old_report)
        self.print_diff()

    def __repr__(self):
        return "<{0}>".format(self.__class__.__name__)

    def print_diff(self):
        """output for debug """
        print self.changed
        print self.added
        print self.removed

    def do_diff(self, obj1, obj2):
        ndiff = obj1.diff(obj2)

        self.do_diff_changed(obj1, obj2, ndiff.changed())
        self.do_diff_added(obj1, obj2, ndiff.added())
        self.do_diff_removed(obj1, obj2, ndiff.removed())

    def nested_obj(self, objname):
        rval = None
        splitted = objname.split("::")
        if len(splitted) == 2:
            rval = splitted
        return rval


    def do_diff_added(self, obj1, obj2, added):
        for akey in added:
            nested = self.nested_obj(akey)
            if nested is not None:
                if nested[0] == 'NmapHost':
                    subobj1 = obj1.get_host_byid(nested[1])
                elif nested[0] == 'NmapService':
                    subobj1 = obj1.get_service_byid(nested[1])
                self.added.append("+ {0}".format(subobj1))
            else:
                self.added.append("+ {0} {1}: {2}".format(obj1, akey, getattr(obj1, akey)))

    def do_diff_removed(self, obj1, obj2, removed):
        for rkey in removed:
            nested = self.nested_obj(rkey)
            if nested is not None:
                if nested[0] == 'NmapHost':
                    subobj2 = obj2.get_host_byid(nested[1])
                elif nested[0] == 'NmapService':
                    subobj2 = obj2.get_service_byid(nested[1])
                self.removed.append("- {0}".format(subobj2))
            else:
                self.removed.append("- {0} {1}: {2}".format(obj2, rkey, getattr(obj2, rkey)))

    def do_diff_changed(self, obj1, obj2, changed):
        for mkey in changed:
            nested = self.nested_obj(mkey)
            if nested is not None:
                if nested[0] == 'NmapHost':
                    subobj1 = obj1.get_host_byid(nested[1])
                    subobj2 = obj2.get_host_byid(nested[1])
                elif nested[0] == 'NmapService':
                    subobj1 = obj1.get_service_byid(nested[1])
                    subobj2 = obj2.get_service_byid(nested[1])
                self.do_diff(subobj1, subobj2)
            else:
                self.changed.append("~ {0} {1}: {2} => {3}".format(obj1, mkey,
                                                    getattr(obj2, mkey),
                                                    getattr(obj1, mkey)))

""" --- """

class NmapReportMeta(db.Model):
    """ Meta Class for NmapReport

        This class needs to copy data from NmapTask Table that can (and will be
        removed from there.. therefore this can not be implemented as foreigen
        key..

    """

    id = db.Column(db.Integer, primary_key=True)
    # "foreign key"/identifier is the NmapTask.task_id (faef323-afec3-a...)
    task_task_id = db.Column(db.String(36))
    task_comment = db.Column(db.String(128))
    task_created = db.Column(db.DateTime)
    task_user_id = db.Column(db.Integer, db.ForeignKey("user.id"))


    def __init__(self, task_id=None):
        self.task_id = task_id
        # TODO .. id ..?! sql.. ? db.session.add(self) + commit()?


    def __repr__(self):
        return "<{0} {1}> TaskID: ({2}), UserID: {4}, Comment: ({3})".format(
                self.__class__.__name__,
                self.id,
                self.task_task_id,
                self.task_comment,
                self.task_user_id)

    @classmethod
    def get_report_meta(cls, **kwargs):
        """get one NmapReport"""

        #NmapReportMeta.query.filter_by(**kwargs).order_by("id")
        return NmapReportMeta.query.filter_by(**kwargs).order_by(asc("id")).all()

    @classmethod
    def get_report(cls, report_id):
        """get one NmapReport"""

        dbp = BackendPluginFactory.create(plugin_name='sql',
                                          url=app.config["LIBNMAP_DB_URI"],
                                          echo=False)
        return dbp.get(report_id=report_id)

    @classmethod
    def get_report_by_task_id(cls, report_id=None, task_id=None):
        """TODO will probably only need either report or task id"""
        pass

    @classmethod
    def getall_reports(cls):
        """getall NmapReport"""

        dbp = BackendPluginFactory.create(plugin_name='sql',
                                          url=app.config["LIBNMAP_DB_URI"],
                                          echo=False)
        return dbp.getall()

    def save_report(self, task_id=None):
        """ TODO """

        _report = NmapTask.get_report(task_id=task_id)

        try:
            dbp = BackendPluginFactory.create(plugin_name="sql",
                                            url=app.config["LIBNMAP_DB_URI"],
                                            echo=False)

            _id = _report.save(dbp)
            r = Address.discover_from_report(report_id=_id)

            # save Meta information of Report
            self.task_task_id = task_id
            self.task_created = datetime.datetime.utcnow()
            # TODO this is murks.. need to add a method to gets 1 NmapTask obj!
            _nmap_task = NmapTask.find(task_id=task_id)
            self.task_comment = _nmap_task[0]["comment"]
            self.task_user_id = _nmap_task[0]["user_id"]

            db.session.add(self)
            db.session.commit()

            return {"rc": 0}

        except Exception as e:
            print e
            return {"rc": 1}

    def create_scan_from_report(self):
        pass


contacts = db.Table("contacts",
    db.Column('contact_id', db.Integer, db.ForeignKey('contact.id')),
    db.Column('address_detail_id', db.Integer, db.ForeignKey('address_detail.id'))
)

class AddressDetail(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    created = db.Column(db.DateTime)
    name = db.Column(db.String(128))
    comment = db.Column(db.String(128))
    source = db.Column(db.String(128))
    ip_address = db.Column(IPAddressType)
    report_id = db.Column(db.Integer)
    contact = db.relationship("Contact", secondary=contacts)

    def __init__(self, id=None, created=datetime.datetime.utcnow(), name=None,
                 comment=None, source=None, ip_address=None, report_id=None):
        self.id = id
        self.created = created
        self.name = name
        self.comment = comment
        self.source = source
        self.ip_address = ip_address
        self.report_id = report_id

    def __repr__(self):
        return "<{0} {1}> ({5}) Name: ({3}) IP: {6}".format(
                self.__class__.__name__,
                self.id,
                self.created,
                self.name,
                self.comment,
                self.source,
                self.ip_address,
                self.report_id)


class Contact(db.Model):
    """ User Class and SQL Table """
    id = db.Column(db.Integer, primary_key=True)
    created = db.Column(db.DateTime)
    name = db.Column(db.String(128))
    email = db.Column(db.String(128))
    address_detail = db.relationship("AddressDetail", secondary=contacts)

    def __init__(self, id=None, created=datetime.datetime.utcnow(), name=None,
            email=None):
        self.id = id
        self.created = created
        self.name = name
        self.email = email

    def __repr__(self):
        return "<{0} {1}> Name: ({3}) Mail: ({4})".format(
                self.__class__.__name__,
                self.id,
                self.created,
                self.name,
                self.email)

class Address(object):
    """ Address class for modeling Scan Targets """

    def __init__(address=None):
        self.address = address

    def __repr__(self):
        return "<{0} {1}>".format(
                self.__class__.__name__,
                self.address)

    @classmethod
    def discover_from_report(cls, report_id):
        """ discover hosts from report """

        nmap_report = NmapReportMeta.get_report(report_id)

        if nmap_report:
            for host in nmap_report._hosts:
                #print("Address: " +  str(host.address) + " is: " + host.status)
                ad = AddressDetail(comment="scanned by me", source="nmap_scan",
                                   ip_address=host.address,
                                   report_id=report_id)
                db.session.add(ad)

            db.session.commit()
            return True

        else:
            print "could not extract report"
            return False


    @classmethod
    def discover_from_reports(cls):
        """ discover hosts """

        nmapreportList = NmapReportMeta.getall_reports()

        all_addresses = []
        for report_id, report_obj in nmapreportList:
            #print str(report_id) + ": " + str(report_obj)
            #print report_obj._hosts
            for host in report_obj._hosts:
                all_addresses.append({"address": host.address, "report_id": report_id})

        print "\n---\n"
        print all_addresses

#EOF
